## @package scp
# Secure Cookie Protocol implementation
#
# See the white paper for details:
# http://www.cse.msu.edu/~alexliu/publications/Cookie/cookie.pdf
#
# The below describes an overview of the goals and implementation
# of the Secure Cookie Protocol. The goals are:
# - Authentication: The cookie proves the user is who they say they are.
# Achieved through SSL Session ID.
# - Condifidentiality: The cookie data is kept secret. Achieved by
# encrypting sensitive information with a symmetric key that
# only the server knows.
# - Integrity: Ensure that the cookie has not been altered. Achieved with
# Key-Hashed Message Authentication Codes.
# - Anti-Replay: Prevent cookie re-use. Achieved through SSL Session ID.
#
# The implementation below uses a fixed size packed structure to store
# the cookie. The fields are as follows:
# - username   => 64 characters
# - expiration => long long
# - data       => 256 characters
# - Session ID => long long
# - Digest     => 20 characters

# system modules
import hashlib
import hmac
import os
import struct
import sys
import time
import unittest
from Crypto.Cipher import AES

# local modules
from log import l

sys.dont_write_byte_code = True

# format specifiers for packing and unpacking cookie data
USER_FMT = '64s'
EXPR_FMT = 'q'
DATA_FMT = '256s'
SESS_FMT = '36s'
DGST_FMT = '20s'

##
# @brief convenience wrapper for turning arbitrary data into readable hex
#
# @param s the stream of data
#
# @return a colon separated string of values
def bytes_to_hex(s):
	return ':'.join(x.encode('hex') for x in s)

##
# @brief compute a Key-Hashed Message Authentication Code
#
# @param msg the message as arbitrary bytes
# @param secret the key as arbitrary bytes
#
# @return 20 byte digest
def HMAC(msg, secret):
	h = hmac.new(secret, digestmod=hashlib.sha1)
	for i in range(100):
		h.update(msg)
	return h.digest()


##
# @brief compute HMAC from user, expiration, and our secret key
#
# @param user username (public)
# @param expiration expiration date (public)
# @param secret secret (private)
#
# @return 20 byte secret key tied to this user and expiration
def hashk(user, expiration, secret):
	msg = struct.pack(USER_FMT + EXPR_FMT, user, expiration)
	return HMAC(msg, secret)

##
# @brief compute HMAC from user, expiration, data, session, and key
#
# @param user username (public)
# @param expiration expiration date (public)
# @param data data to be encrypted in the cookie (private)
# @param session SSL session ID (public)
# @param key secret key generated by HMAC of user/expiration/secret
#
# @return 20 byte authentication code of cookie data
def hashd(user, expiration, data, session, key):
	msg = struct.pack(USER_FMT + EXPR_FMT + DATA_FMT + SESS_FMT,
			user, expiration, data, session)
	return HMAC(msg, key)

##
# @brief encrypt a message with AES
#
# @param msg the message to encrypt (multiple of 16 bytes)
# @param key 16 byte secret key (private)
# @param iv 16 byte initialization vector (public)
#
# @return ciphertext
def encrypt(msg, key, iv):
	# TODO: validate inputs
	crypter = AES.new(key, AES.MODE_CBC, iv)
	return crypter.encrypt(msg)
##
# @brief decrypt a message with AES
#
# @param msg the message to decrypt (multiple of 16 bytes)
# @param key 16 byte secret key (private)
# @param iv 16 byte initialization vector (public)
#
# @return plaintext
def decrypt(msg, key, iv):
	# TODO: validate inputs
	crypter = AES.new(key, AES.MODE_CBC, iv)
	return crypter.decrypt(msg)

##
# @brief Secure Cookie implementation
class SecureCookie:
	##
	# @brief initialize a cookie that is unique per session
	#
	# @param session unique identifying information about the session (public)
	# @param secret secret key uses for encrypting all cookies
	#
	# @return SecureCookie object
	def __init__(self, session, secret):
		s = hashlib.sha1()
		s.update(session)
		self._session = session
		self._secret = secret
		self._ivec = s.digest()[:16]
	##
	# @brief convert inputs to a packed data structure suiteable for
	# passing to the client
	#
	# @param user any tag that identifies the owner of the data (public)
	# @param expiration time at which the cookie has expired (public)
	# @param data any data we wish to store with the client (private)
	#
	# @return stream that can be used to set a client cookie
	def serialize(self, user, expiration, data):
		key = hashk(user, expiration, self._secret)
		mac = hashd(user, expiration, data, self._session, str(key))
		ciphertext = encrypt(data.ljust(256, '\0'), str(key)[:16], self._ivec)
		return struct.pack(USER_FMT + EXPR_FMT + DATA_FMT + DGST_FMT,
				user, expiration, ciphertext, mac)
	##
	# @brief convert a cookie stream into it's individual components
	#
	# @param cookie cookie stream created by serialize()
	#
	# @return (user, expiration, encrypted data, mac)
	def deserialize(self, cookie):
		unpacked = struct.unpack(USER_FMT + EXPR_FMT + DATA_FMT + DGST_FMT, cookie)
		if len(unpacked) != 4:
			l.error("Failed to unpack cookie data.")
		user = unpacked[0]
		expiration = unpacked[1]
		ciphertext = unpacked[2]
		mac = unpacked[3]
		return (user.rstrip('\0'), expiration, ciphertext.rstrip('\0'), mac)
	##
	# @brief get the expiration time of a cookie
	#
	# @param cookie cookie stream created by serialize()
	#
	# @return expiration time integer
	def getExpiration(self, cookie):
		(user, expiration, ciphertext, mac) = self.deserialize(cookie)
		return expiration
	##
	# @brief set the expiration time of a cookie
	#
	# @param cookie the original cookie stream created by serialize()
	# @param expiration the new expiration time
	#
	# @return serialized cookie stream with updated expiration
	def setExpiration(self, cookie, expiration):
		if not self.isValid(cookie):
			l.warn("SECURITY ALERT: Setting expiration on invalid cookie.")
		(user, _, ciphertext, _) = self.deserialize(cookie)
		plaintext = self.getData(cookie)
		return self.serialize(user, expiration, plaintext)
	##
	# @brief get the data from a cookie
	#
	# @param cookie cookie stream created by serialize()
	#
	# @return decrypted data section of the cookie
	def getData(self, cookie):
		(user, expiration, ciphertext, mac) = self.deserialize(cookie)
		key = hashk(user, expiration, self._secret)
		plaintext = decrypt(ciphertext.ljust(256, '\0'), str(key)[:16], self._ivec)
		return plaintext.rstrip('\0')
	##
	# @brief set data field for a cookie
	#
	# @param cookie the original cookie stream created by serialize()
	# @param data the new data
	#
	# @return serialize cookie stream with updated data
	def setData(self, cookie, data):
		if not self.isValid(cookie):
			l.warn("SECURITY ALERT: Setting data on invalid cookie.")
		(user, expiration, _, _) = self.deserialize(cookie)
		return self.serialize(user, expiration, data)
	##
	# @brief detect if the cookie integrity has been compromised.
	#
	# @param cookie the cookie stream created by serialize()
	#
	# @return  True or False
	def isValid(self, cookie):
		(user, expiration, ciphertext, mac) = self.deserialize(cookie)
		key = hashk(user, expiration, self._secret)
		plaintext = decrypt(ciphertext.ljust(256, '\0'), str(key)[:16], self._ivec)
		vmac = hashd(user, expiration, plaintext, self._session, str(key))
		if mac == vmac:
			return True
		return False

# Values for testing
TEST_USER = 'mytestuser'
TEST_EXPIRATION = int(time.time())
TEST_DATA = 'mytestdata'
TEST_SESSION = '123456789009876543211234567890'

class TestSecureCookie(unittest.TestCase):
	def setUp(self):
		self.secret = os.urandom(16)
	def test_init(self):
		c = SecureCookie(TEST_SESSION, self.secret)
		self.assertFalse(c is None)
		self.assertFalse(c._session is None)
		self.assertFalse(c._secret is None)
		self.assertFalse(c._ivec is None)
	def test_serialize(self):
		c = SecureCookie(TEST_SESSION, self.secret)
		self.assertFalse(c is None)
		s = c.serialize(TEST_USER, TEST_EXPIRATION, TEST_DATA)
		self.assertFalse(s is None)
	def test_deserialize(self):
		c = SecureCookie(TEST_SESSION, self.secret)
		self.assertFalse(c is None)
		s = c.serialize(TEST_USER, TEST_EXPIRATION, TEST_DATA)
		self.assertFalse(s is None)
		d = c.deserialize(s)
		self.assertEqual(( TEST_USER, TEST_EXPIRATION, ), ( d[0], d[1], ))
	def test_getData(self):
		c = SecureCookie(TEST_SESSION, self.secret)
		self.assertFalse(c is None)
		s = c.serialize(TEST_USER, TEST_EXPIRATION, TEST_DATA)
		self.assertFalse(s is None)
		d = c.getData(s)
		self.assertEqual(TEST_DATA, d)
	def test_setData(self):
		c = SecureCookie(TEST_SESSION, self.secret)
		self.assertFalse(c is None)
		s = c.serialize(TEST_USER, TEST_EXPIRATION, TEST_DATA)
		self.assertFalse(s is None)
		s2 = c.setData(s, TEST_DATA + 'more')
		self.assertFalse(s2 is None)
		d = c.getData(s2)
		self.assertEqual(d, TEST_DATA + 'more')
	def test_getExpiration(self):
		c = SecureCookie(TEST_SESSION, self.secret)
		self.assertFalse(c is None)
		s = c.serialize(TEST_USER, TEST_EXPIRATION, TEST_DATA)
		self.assertFalse(s is None)
		e = c.getExpiration(s)
		self.assertEqual(TEST_EXPIRATION, e)
	def test_setExpiration(self):
		c = SecureCookie(TEST_SESSION, self.secret)
		self.assertFalse(c is None)
		s = c.serialize(TEST_USER, TEST_EXPIRATION, TEST_DATA)
		self.assertFalse(s is None)
		s2 = c.setExpiration(s, TEST_EXPIRATION + 1)
		self.assertFalse(s2 is None)
		e = c.getExpiration(s2)
		self.assertTrue(e, TEST_EXPIRATION + 1)
	def test_isValid(self):
		c = SecureCookie(TEST_SESSION, self.secret)
		self.assertFalse(c is None)
		s = c.serialize(TEST_USER, TEST_EXPIRATION, TEST_DATA)
		self.assertFalse(s is None)
		self.assertTrue(c.isValid(s))

if __name__ == "__main__":
	# run from the same directory as the module
	os.chdir(os.path.dirname(os.path.abspath(sys.argv[0])))
	sys.exit(unittest.main(verbosity=2))
