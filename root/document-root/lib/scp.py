## @package scp
# Secure Cookie Protocol implementation
#
# See the white paper for details:
# http://www.cse.msu.edu/~alexliu/publications/Cookie/cookie.pdf
#
# The below describes an overview of the goals and implementation
# of the Secure Cookie Protocol. The goals are:
# - Authentication: The cookie proves the user is who they say they are.
# Achieved through SSL Session ID.
# - Condifidentiality: The cookie data is kept secret. Achieved by
# encrypting sensitive information with a symmetric key that
# only the server knows.
# - Integrity: Ensure that the cookie has not been altered. Achieved with
# Key-Hashed Message Authentication Codes.
# - Anti-Replay: Prevent cookie re-use. Achieved through SSL Session ID.
#
# The implementation below uses a fixed size packed structure to store
# the cookie. The fields are as follows:
# - username   => 32 characters
# - expiration => long long
# - data       => 256 characters
# - Session ID => long long
# - Digest     => 20 characters

# system modules
import hashlib
import hmac
import os
import struct
import sys
import time
import unittest
from Crypto.Cipher import AES

# local modules
from log import l

sys.dont_write_byte_code = True

# format specifiers for packing and unpacking cookie data
USER_FMT = '32s'
EXPR_FMT = 'q'
DATA_FMT = '256s'
SESS_FMT = 'q'
DGST_FMT = '20s'

# Secret key contents
secret_key = None

##
# @brief convenience wrapper for turning arbitrary data into readable hex
#
# @param s the stream of data
#
# @return a colon separated string of values
def bytes_to_hex(s):
	return ':'.join(x.encode('hex') for x in s)

##
# @brief compute a Key-Hashed Message Authentication Code
#
# @param msg the message as arbitrary bytes
# @param secret the key as arbitrary bytes
#
# @return 20 byte digest
def HMAC(msg, secret):
	h = hmac.new(secret, digestmod=hashlib.sha1)
	for i in range(100):
		h.update(msg)
	return h.digest()


##
# @brief compute HMAC from user, expiration, and our secret key
#
# @param user username (public)
# @param expiration expiration date (public)
# @param secret secret (private)
#
# @return 20 byte secret key tied to this user and expiration
def hashk(user, expiration, secret):
	msg = struct.pack(USER_FMT + EXPR_FMT, user, expiration)
	return HMAC(msg, secret)

##
# @brief compute HMAC from user, expiration, data, session, and key
#
# @param user username (public)
# @param expiration expiration date (public)
# @param data data to be encrypted in the cookie (private)
# @param session SSL session ID (public)
# @param key secret key generated by HMAC of user/expiration/secret
#
# @return 20 byte authentication code of cookie data
def hashd(user, expiration, data, session, key):
	msg = struct.pack(USER_FMT + EXPR_FMT + DATA_FMT + SESS_FMT,
			user, expiration, data, session)
	return HMAC(msg, key)

##
# @brief encrypt a message with AES
#
# @param msg the message to encrypt (multiple of 16 bytes)
# @param key 16 byte secret key (private)
# @param iv 16 byte initialization vector (public)
#
# @return ciphertex
def encrypt(msg, key, iv):
	# TODO: validate inputs
	crypter = AES.new(key, AES.MODE_CBC, iv)
	return crypter.encrypt(msg)
##
# @brief decrypt a message with AES
#
# @param msg the message to decrypt (multiple of 16 bytes)
# @param key 16 byte secret key (private)
# @param iv 16 byte initialization vector (public)
#
# @return plaintext
def decrypt(msg, key, iv):
	# TODO: validate inputs
	crypter = AES.new(key, AES.MODE_CBC, iv)
	return crypter.decrypt(msg)

##
# @brief determine whether a cookie is valid
#
# @param cookie cookie data (public).
# @param session SSL session ID (public)
#
# @return  True or False
def is_valid(cookie_data, session):
	if not secret_key:
		l.error("Cannot validate cookie. Secret key uninitialized.")
	unpacked = struct.unpack(USER_FMT + EXPR_FMT + DATA_FMT + DGST_FMT, cookie_data)
	if len(unpacked) != 4:
		l.error("Failed to unpack cookie data.")
	user = unpacked[0]
	exp = unpacked[1]
	ciphertext = unpacked[2]
	hashed_data = unpacked[3]
	hash_key = hashk(user, exp, secret_key)
	# we need a way to consistently create the initialization vector.
	# we can simply hash the session key to get deterministic output
	s = hashlib.sha1()
	s.update(str(session))
	i_vec = s.digest()[:16]
	plaintext = decrypt(ciphertext.ljust(256,'\0'), str(hash_key)[:16], i_vec)
	verified_hash = hashd(user, exp, plaintext, session, str(hash_key))
	if hashed_data == verified_hash:
		return True
	else:
		return False

##
# @brief Implementation of Secure Cookie Protocal
class SecureCookie:
	##
	# @brief Initialize packed cookie data
	#
	# @param user username (public)
	# @param exp cookie expiration date (public)
	# @param data any data to be stored securely (private)
	# @param session SSL session ID (public)
	#
	# @return a Secure Cookie object suitable for passing to the client
	def __init__(self, user, exp, data, session):
		if not secret_key:
			l.error("Failed to instantiate %s: "
					"No secret key initialized."
					% self.__class__.__name__)
			return None
		hash_key = hashk(user, exp, secret_key)
		hashed_data = hashd(user, exp, data, session, str(hash_key))
		# we need a way to consistently create the initialization vector.
		# we can simply hash the session key to get deterministic output
		s = hashlib.sha1()
		s.update(str(session))
		i_vec = s.digest()[:16]
		ciphertext = encrypt(data.ljust(256, '\0'), str(hash_key)[:16], i_vec)
		self.value = struct.pack(USER_FMT + EXPR_FMT + DATA_FMT + DGST_FMT,
				user, exp, ciphertext, hashed_data)
# Values for testing
TEST_USER = 'mytestuser'
TEST_EXPIRATION = time.time()
TEST_DATA = 'mytestdata'
TEST_SESSION = 12345

class TestSecureCookie(unittest.TestCase):
	def setUp(self):
		global secret_key
		secret_key = os.urandom(16)
	def test_init(self):
		self.assertTrue(SecureCookie(TEST_USER, TEST_EXPIRATION, TEST_DATA, TEST_SESSION))
	def test_verify(self):
		cookie = SecureCookie(TEST_USER, TEST_EXPIRATION, TEST_DATA, TEST_SESSION)
		self.assertTrue(cookie)
		self.assertTrue(is_valid(cookie.value, TEST_SESSION))

if __name__ == "__main__":
	# run from the same directory as the module
	os.chdir(os.path.dirname(os.path.abspath(sys.argv[0])))
	sys.exit(unittest.main(verbosity=2))
