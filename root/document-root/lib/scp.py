## @package scp
# Secure Cookie Protocol implementation
#
# See the white paper for details:
# http://www.cse.msu.edu/~alexliu/publications/Cookie/cookie.pdf
#
# The below describes an overview of the goals and implementation
# of the Secure Cookie Protocol. The goals are:
# - Authentication: The cookie proves the user is who they say they are.
# Achieved through SSL Session ID.
# - Condifidentiality: The cookie data is kept secret. Achieved by
# encrypting sensitive information with a symmetric key that
# only the server knows.
# - Integrity: Ensure that the cookie has not been altered. Achieved with
# Key-Hashed Message Authentication Codes.
# - Anti-Replay: Prevent cookie re-use. Achieved through SSL Session ID.
#
# The implementation below uses a fixed size packed structure to store
# the cookie. The fields are as follows:
# - username   => 64 characters
# - expiration => long long
# - data       => 256 characters
# - Session ID => long long
# - Digest     => 20 characters

# system modules
import hashlib
import hmac
import os
import struct
import sys
import time
import unittest
from Crypto.Cipher import AES

# local modules
from log import l

sys.dont_write_byte_code = True

# format specifiers for packing and unpacking cookie data
USER_FMT = '64s'
EXPR_FMT = 'q'
DATA_FMT = '256s'
SESS_FMT = '36s'
DGST_FMT = '20s'

##
# @brief convenience wrapper for turning arbitrary data into readable hex
#
# @param s the stream of data
#
# @return a colon separated string of values
def bytes_to_hex(s):
	return ':'.join(x.encode('hex') for x in s)

##
# @brief compute a Key-Hashed Message Authentication Code
#
# @param msg the message as arbitrary bytes
# @param secret the key as arbitrary bytes
#
# @return 20 byte digest
def HMAC(msg, secret):
	h = hmac.new(secret, digestmod=hashlib.sha1)
	for i in range(100):
		h.update(msg)
	return h.digest()


##
# @brief compute HMAC from user, expiration, and our secret key
#
# @param user username (public)
# @param expiration expiration date (public)
# @param secret secret (private)
#
# @return 20 byte secret key tied to this user and expiration
def hashk(user, expiration, secret):
	msg = struct.pack(USER_FMT + EXPR_FMT, user, expiration)
	return HMAC(msg, secret)

##
# @brief compute HMAC from user, expiration, data, session, and key
#
# @param user username (public)
# @param expiration expiration date (public)
# @param data data to be encrypted in the cookie (private)
# @param session SSL session ID (public)
# @param key secret key generated by HMAC of user/expiration/secret
#
# @return 20 byte authentication code of cookie data
def hashd(user, expiration, data, session, key):
	msg = struct.pack(USER_FMT + EXPR_FMT + DATA_FMT + SESS_FMT,
			user, expiration, data, session)
	return HMAC(msg, key)

##
# @brief encrypt a message with AES
#
# @param msg the message to encrypt (multiple of 16 bytes)
# @param key 16 byte secret key (private)
# @param iv 16 byte initialization vector (public)
#
# @return ciphertext
def encrypt(msg, key, iv):
	# TODO: validate inputs
	crypter = AES.new(key, AES.MODE_CBC, iv)
	return crypter.encrypt(msg)
##
# @brief decrypt a message with AES
#
# @param msg the message to decrypt (multiple of 16 bytes)
# @param key 16 byte secret key (private)
# @param iv 16 byte initialization vector (public)
#
# @return plaintext
def decrypt(msg, key, iv):
	# TODO: validate inputs
	crypter = AES.new(key, AES.MODE_CBC, iv)
	return crypter.decrypt(msg)

##
# @brief determine whether a cookie is valid
#
# @param cookie cookie data (public).
# @param session SSL session ID (public)
#
# @return  True or False
def is_valid(cookie_data, session):
	if not secret:
		l.error("Cannot validate cookie. Secret key uninitialized.")
	unpacked = struct.unpack(USER_FMT + EXPR_FMT + DATA_FMT + DGST_FMT, cookie_data)
	if len(unpacked) != 4:
		l.error("Failed to unpack cookie data.")
	user = unpacked[0]
	exp = unpacked[1]
	ciphertext = unpacked[2]
	hashed_data = unpacked[3]
	hash_key = hashk(user, exp, secret)
	# we need a way to consistently create the initialization vector.
	# we can simply hash the session key to get deterministic output
	s = hashlib.sha1()
	s.update(str(session))
	i_vec = s.digest()[:16]
	plaintext = decrypt(ciphertext.ljust(256,'\0'), str(hash_key)[:16], i_vec)
	verified_hash = hashd(user, exp, plaintext, session, str(hash_key))
	if hashed_data == verified_hash:
		return True
	else:
		return False

class SecureCookie:
	def __init__(self, session, secret):
		s = hashlib.sha1()
		s.update(session)
		self._session = session
		self._secret = secret
		self._ivec = s.digest()[:16]
	def serialize(self, user, expiration, data):
		key = hashk(user, expiration, self._secret)
		mac = hashd(user, expiration, data, self._session, str(key))
		ciphertext = encrypt(data.ljust(256, '\0'), str(key)[:16], self._ivec)
		return struct.pack(USER_FMT + EXPR_FMT + DATA_FMT + DGST_FMT,
				user, expiration, ciphertext, mac)
	def deserialize(self, cookie):
		unpacked = struct.unpack(USER_FMT + EXPR_FMT + DATA_FMT + DGST_FMT, cookie)
		if len(unpacked) != 4:
			l.error("Failed to unpack cookie data.")
		user = unpacked[0]
		expiration = unpacked[1]
		ciphertext = unpacked[2]
		mac = unpacked[3]
		return (user.rstrip('\0'), expiration, ciphertext.rstrip('\0'), mac)
	def getExpiration(self, cookie):
		(user, expiration, ciphertext, mac) = self.deserialize(cookie)
		return expiration
	def setExpiration(self, cookie, expiration):
		if not self.isValid(cookie):
			l.warn("SECURITY ALERT: Setting expiration on invalid cookie.")
		(user, _, ciphertext, _) = self.deserialize(cookie)
		plaintext = self.getData(cookie)
		return self.serialize(user, expiration, plaintext)
	def getData(self, cookie):
		(user, expiration, ciphertext, mac) = self.deserialize(cookie)
		key = hashk(user, expiration, self._secret)
		plaintext = decrypt(ciphertext.ljust(256, '\0'), str(key)[:16], self._ivec)
		return plaintext.rstrip('\0')
	def setData(self, cookie, data):
		if not self.isValid(cookie):
			l.warn("SECURITY ALERT: Setting data on invalid cookie.")
		(user, expiration, _, _) = self.deserialize(cookie)
		return self.serialize(user, expiration, data)
	def isValid(self, cookie):
		(user, expiration, ciphertext, mac) = self.deserialize(cookie)
		key = hashk(user, expiration, self._secret)
		plaintext = decrypt(ciphertext.ljust(256, '\0'), str(key)[:16], self._ivec)
		vmac = hashd(user, expiration, plaintext, self._session, str(key))
		if mac == vmac:
			return True
		return False

##
# @brief Implementation of Secure Cookie Protocol
#class SecureCookie:
	##
	# @brief Initialize packed cookie data
	#
	# @param user username (public)
	# @param exp cookie expiration date (public)
	# @param data any data to be stored securely (private)
	# @param session SSL session ID (public)
	#
	# @return a Secure Cookie object suitable for passing to the client
#	def __init__(self, user, exp, data, session):
#		if not secret_key:
#			l.error("Failed to instantiate %s: "
#					"No secret key initialized."
#					% self.__class__.__name__)
#			return None
#		hash_key = hashk(user, exp, secret_key)
#		hashed_data = hashd(user, exp, data, session, str(hash_key))
#		# we need a way to consistently create the initialization vector.
#		# we can simply hash the session key to get deterministic output
#		s = hashlib.sha1()
#		s.update(str(session))
#		i_vec = s.digest()[:16]
#		ciphertext = encrypt(data.ljust(256, '\0'), str(hash_key)[:16], i_vec)
#		self.cookie = struct.pack(USER_FMT + EXPR_FMT + DATA_FMT + DGST_FMT,
#				user, exp, ciphertext, hashed_data)
#		self._user = user
#		self._expiration = exp
#		self._ciphertext = ciphertext
#		self._i_vec = i_vec
#	@property
#	def user(self):
#		return self._user
#	@property
#	def data(self):
#		hash_key = hashk(self._user, self._expiration, secret_key)
#		plaintext = decrypt(self._ciphertext, str(hash_key)[:16], self._i_vec)
#		return plaintext

# Values for testing
TEST_USER = 'mytestuser'
TEST_EXPIRATION = int(time.time())
TEST_DATA = 'mytestdata'
TEST_SESSION = '123456789009876543211234567890'

class TestSecureCookie(unittest.TestCase):
	def setUp(self):
		self.secret = os.urandom(16)
	def test_init(self):
		c = SecureCookie(TEST_SESSION, self.secret)
		self.assertFalse(c is None)
		self.assertFalse(c._session is None)
		self.assertFalse(c._secret is None)
		self.assertFalse(c._ivec is None)
	def test_serialize(self):
		c = SecureCookie(TEST_SESSION, self.secret)
		self.assertFalse(c is None)
		s = c.serialize(TEST_USER, TEST_EXPIRATION, TEST_DATA)
		self.assertFalse(s is None)
	def test_deserialize(self):
		c = SecureCookie(TEST_SESSION, self.secret)
		self.assertFalse(c is None)
		s = c.serialize(TEST_USER, TEST_EXPIRATION, TEST_DATA)
		self.assertFalse(s is None)
		d = c.deserialize(s)
		self.assertEqual(( TEST_USER, TEST_EXPIRATION, ), ( d[0], d[1], ))
	def test_getData(self):
		c = SecureCookie(TEST_SESSION, self.secret)
		self.assertFalse(c is None)
		s = c.serialize(TEST_USER, TEST_EXPIRATION, TEST_DATA)
		self.assertFalse(s is None)
		d = c.getData(s)
		self.assertEqual(TEST_DATA, d)
	def test_setData(self):
		c = SecureCookie(TEST_SESSION, self.secret)
		self.assertFalse(c is None)
		s = c.serialize(TEST_USER, TEST_EXPIRATION, TEST_DATA)
		self.assertFalse(s is None)
		s2 = c.setData(s, TEST_DATA + 'more')
		self.assertFalse(s2 is None)
		d = c.getData(s2)
		self.assertEqual(d, TEST_DATA + 'more')
	def test_getExpiration(self):
		c = SecureCookie(TEST_SESSION, self.secret)
		self.assertFalse(c is None)
		s = c.serialize(TEST_USER, TEST_EXPIRATION, TEST_DATA)
		self.assertFalse(s is None)
		e = c.getExpiration(s)
		self.assertEqual(TEST_EXPIRATION, e)
	def test_setExpiration(self):
		c = SecureCookie(TEST_SESSION, self.secret)
		self.assertFalse(c is None)
		s = c.serialize(TEST_USER, TEST_EXPIRATION, TEST_DATA)
		self.assertFalse(s is None)
		s2 = c.setExpiration(s, TEST_EXPIRATION + 1)
		self.assertFalse(s2 is None)
		e = c.getExpiration(s2)
		self.assertTrue(e, TEST_EXPIRATION + 1)
	def test_isValid(self):
		c = SecureCookie(TEST_SESSION, self.secret)
		self.assertFalse(c is None)
		s = c.serialize(TEST_USER, TEST_EXPIRATION, TEST_DATA)
		self.assertFalse(s is None)
		self.assertTrue(c.isValid(s))


if __name__ == "__main__":
	# run from the same directory as the module
	os.chdir(os.path.dirname(os.path.abspath(sys.argv[0])))
	sys.exit(unittest.main(verbosity=2))
